name: CI â€” tests only (testing branch)

on:
  push:
    branches: [ testing ]
  pull_request:
    branches: [ testing ]

jobs:
  tests:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      # Start only what's needed for tests. We run all DBs + product_service
      # so order_service tests can call the product API if they need to.
      - name: Start compose services required for tests
        run: |
          docker compose up -d --build product_db order_db customer_db product_service

      - name: Wait for Postgres containers to be ready
        run: |
          docker compose ps
          for c in product_db_container order_db_container customer_db_container; do
            echo "Waiting for $c ..."
            for i in {1..30}; do
              if docker exec "$c" pg_isready -U postgres >/dev/null 2>&1; then
                echo "$c is ready"
                break
              fi
              sleep 2
            done
          done

      - name: Create venv & install dev dependencies
        run: |
          python -m venv .venv
          source .venv/bin/activate
          pip install -U pip
          pip install -r backend/product_service/requirements-dev.txt
          pip install -r backend/order_service/requirements-dev.txt
          pip install -r backend/customer_service/requirements-dev.txt

      - name: Run product_service tests
        env:
          POSTGRES_HOST: localhost
          POSTGRES_PORT: '5432'
          POSTGRES_DB: products
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
        run: |
          source .venv/bin/activate
          cd backend/product_service
          pytest -q

      - name: Run order_service tests
        env:
          POSTGRES_HOST: localhost
          POSTGRES_PORT: '5433'
          POSTGRES_DB: orders
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          PRODUCT_SERVICE_URL: http://localhost:8000
        run: |
          source .venv/bin/activate
          cd backend/order_service
          pytest -q

      - name: Run customer_service tests
        env:
          POSTGRES_HOST: localhost
          POSTGRES_PORT: '5434'
          POSTGRES_DB: customers
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
        run: |
          source .venv/bin/activate
          cd backend/customer_service
          pytest -q

      - name: Tear down compose (always)
        if: always()
        run: docker compose down -v

  build_and_push:


    name: Build & push images to ACR
    needs: tests
    runs-on: ubuntu-latest
    env:
      ACR_NAME: ${{ vars.ACR_NAME || secrets.ACR_NAME }}
      ACR_LOGIN_SERVER: ${{ vars.ACR_LOGIN_SERVER || secrets.ACR_LOGIN_SERVER }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Log in to ACR using the service principal in AZURE_CREDENTIALS
      - name: Azure login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Docker login to ACR
        uses: azure/docker-login@v2
        with:
          login-server: ${{ env.ACR_LOGIN_SERVER }}
          username: ${{ fromJSON(secrets.AZURE_CREDENTIALS).clientId }}
          password: ${{ fromJSON(secrets.AZURE_CREDENTIALS).clientSecret }}

      - name: Enable Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build & push product_service
        run: |
          docker build -t "$ACR_LOGIN_SERVER/product:${{ github.sha }}" ./backend/product_service
          docker push "$ACR_LOGIN_SERVER/product:${{ github.sha }}"

      - name: Build & push order_service
        run: |
          docker build -t "$ACR_LOGIN_SERVER/order:${{ github.sha }}" ./backend/order_service
          docker push "$ACR_LOGIN_SERVER/order:${{ github.sha }}"

      - name: Build & push customer_service
        run: |
          docker build -t "$ACR_LOGIN_SERVER/customer:${{ github.sha }}" ./backend/customer_service
          docker push "$ACR_LOGIN_SERVER/customer:${{ github.sha }}"

      - name: Build & push frontend
        run: |
          docker build -t "$ACR_LOGIN_SERVER/frontend:${{ github.sha }}" ./frontend
          docker push "$ACR_LOGIN_SERVER/frontend:${{ github.sha }}"

  deploy_staging:
    name: Deploy to ephemeral staging (AKS)
    needs: build_and_push
    runs-on: ubuntu-latest
    env:
      ACR_LOGIN_SERVER: ${{ vars.ACR_LOGIN_SERVER || secrets.ACR_LOGIN_SERVER }}
      AKS_RESOURCE_GROUP: ${{ vars.AKS_RESOURCE_GROUP || secrets.AKS_RESOURCE_GROUP }}
      AKS_CLUSTER_NAME: ${{ vars.AKS_CLUSTER_NAME || secrets.AKS_CLUSTER_NAME }}
      NS: stg-${{ github.run_id }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS context
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ env.AKS_RESOURCE_GROUP }}
          cluster-name: ${{ env.AKS_CLUSTER_NAME }}

      - name: Create staging namespace
        run: |
          kubectl create namespace "${NS}" || echo "namespace exists"

      - name: Render manifests with ACR images (commit SHA)
        run: |
          mkdir -p k8s_rendered
          ACR="${ACR_LOGIN_SERVER}"
          SHA="${{ github.sha }}"

          for f in k8s/*.yaml; do
            sed -e "s|REPLACE_ME|${ACR}|g" -e "s|TAG|${SHA}|g" "$f" > "k8s_rendered/$(basename "$f")"
          done

          echo "Rendered files:"
          ls -l k8s_rendered

      - name: Apply rendered manifests
        run: |
          kubectl apply -n "${NS}" -f k8s_rendered/

      - name: Wait for DBs ready
        run: |
          kubectl -n "${NS}" rollout status deploy/product-db --timeout=180s
          kubectl -n "${NS}" rollout status deploy/order-db   --timeout=180s
          kubectl -n "${NS}" rollout status deploy/customer-db --timeout=180s

      - name: Debug pods & events
        if: always()
        run: |
          kubectl -n "${NS}" get pods -o wide
          for a in product order customer frontend; do
            echo "=== $a ==="
            kubectl -n "${NS}" describe deploy/$a || true
            kubectl -n "${NS}" get pods -l app=$a -o name | xargs -r -I{} sh -c 'echo "*** {}"; kubectl -n "${NS}" describe {}; kubectl -n "${NS}" logs --tail=200 {} || true'
          done
          kubectl -n "${NS}" get events --sort-by=.lastTimestamp | tail -n 200

      - name: Wait for apps ready
        run: |
          kubectl -n "${NS}" rollout status deploy/product  --timeout=300s
          kubectl -n "${NS}" rollout status deploy/order    --timeout=300s
          kubectl -n "${NS}" rollout status deploy/customer --timeout=300s
          kubectl -n "${NS}" rollout status deploy/frontend --timeout=300s

      - name: Smoke test (in-cluster curl pod)
        run: |
          kubectl -n "${NS}" run curl --image=curlimages/curl:8.10.1 --restart=Never --command -- \
            sh -c '
              set -e
              echo "Hit product root:";   curl -sf http://product:8000/   | head -c 200; echo
              echo "Hit order root:";     curl -sf http://order:8000/     | head -c 200; echo
              echo "Hit customer root:";  curl -sf http://customer:8000/  | head -c 200; echo
            '
          # Cleanup the curl pod
          kubectl -n "${NS}" delete pod curl --wait=true

      - name: Cleanup staging namespace (always)
        if: always()
        run: |
          kubectl delete namespace "${NS}" --ignore-not-found=true --wait=false
